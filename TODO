Next high-level goal: Start prototyping gameplay
* Cleaner ECS setup - use Object class + subsystem, asset providers [X]
* Characters - procedural cubes
** Procedural meshes + rendering
* A little more math - 3D rotations
* 3D camera
* Input subsystem/component and game controls
** Reasonable association between devices and players. 
*** Multiple control contexts. Navigating menu vs. in-game?
**** Must assign controllers to instantiate sensible local game control context.
**** Network control device for online session.
*** Keyboard always p1 for now.
** Raw state (this frame, previous frame) - bit fields
*** Device-to-bit-index mappings for raw state. Bit indices defined per-game.
*** i.e. GLFW_GAMEPAD_BUTTON_Y -> SANDBOX_INPUT_JUMP
** Held, released states (input index corresponds to bitfield index)
* SandboxGame -> PaddleArena
* Stage/Arena
* Actual paddles and paddle proportions
* Collision
** Need a fixed-capacity *array*. Dodge the allocator biz.
*** Collision subsystem is mixing heap and fixed allocation again. Fix it.
** Collision geometry in object-local space. Requires some more math.
* "Ball" - procedural cube, 3d rigidbody
* Maintain aspect ratio !

AFTER GAMEPLAY VALIDATION:
* Messaging system so callbacks from components can happen?
* Some basic ECS cleanup
** UUIDs, not enums
** Get rid of Create/ReleaseComponent() calls? Or allow for constructor params.
