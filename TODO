Next high-level goal: Start prototyping gameplay
* Cleaner ECS setup - use Object class + subsystem, asset providers [X]
* Characters - procedural cubes
** Procedural meshes + rendering
* A little more math - 3D rotations
* 3D camera
* Input subsystem/component and game controls
** Reasonable association between devices and players. 
*** Multiple control contexts. Navigating menu vs. in-game?
**** Must assign controllers to instantiate sensible local game control context.
**** Network control device for online session.
*** Keyboard always p1 for now.
** Raw state (this frame, previous frame) - bit fields
*** Device-to-bit-index mappings for raw state. Bit indices defined per-game.
*** i.e. GLFW_GAMEPAD_BUTTON_Y -> SANDBOX_INPUT_JUMP
** Held, released states (input index corresponds to bitfield index)
* SandboxGame -> PaddleArena
* Stage/Arena
* Actual paddles and paddle proportions
* Collision
** Collision geometry in object-local space. Requires some more math.
* Collision handling, overlap resolution
** Check out: https://blog.hamaluik.ca/posts/simple-aabb-collision-using-minkowski-difference/
* "Ball" - procedural cube, 3d rigidbody (!)
* Debug + Fix collision flags not working as intended
* Volumetric fonts 

* Scoring & display
** Need to revisit a few fundamental questions: what is the "resolution" 
   for this game? Need this for proper font rendering, and to properly
   capture the general illusion of OLD GAEM.
** Worry about this after the font rasterizer works :P

* Full game loop (losing + winning)
* Maintain aspect ratio !
* Render middle of the arena

* Serialization & Rollback Redux
** Fix the memory management story
** Come up with a real serialization solution
** Handles rather than pointers where appropriate
** Serializable pointers where appropriate (prototype in s_ptr)
** Synctest support to validate, sanity check
** Debug support for loading, saving state

* Start on netplay support after maybe a *little* cleanup

ENGINE AFTER GAMEPLAY SLICE:
* Messaging/Event system so callbacks from components can happen without introducing gross dependencies everywhere? 
* Some basic ECS cleanup
** UUIDs, not enums?
** Get rid of Create/ReleaseComponent() calls?
** Allow for more than one component per object for a given component type.
* Debug drawing
* Hot-reloading for C++ changes
* Hot-reloading for assets

* UI
** Not sure exactly where to start here, but starting would be good!
