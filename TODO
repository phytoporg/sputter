Next high-level goal: Gameplay vertical slice
* Some kind of basic UI flow for actual game loop
** Main menu w/Title, "Vs. AI" | "Vs. Player" | "Online" (greyed out as appropriate)
** Need a notion of scenes (main menu -> game and back)
*** Refactor PaddleArena to deal with scenes and scene management, gameplay into a game instance
** Need a less convoluted way to get player inputs for UI
** Just need keyboard/controller-friendly interface for now. 
** Will require flushing out more font rendering bugs, possibly a non-volumetric
   rendering option for glyphs (render-to-texture? quad instances + texture atlas?)

* UI WORK STATUS
** Plumb in basic events, keyboard UI navigation [DONE]
*** Focus management [DONE]

** Then, start thinking about text

* BUGBUG:
** On MUTHUR, all game objects are red for some reason after copying over shaders.

* A real AI that sucks less

* More gameplay iteration
** Proper serve mechanic, at the very least
** Smoother game loop
** Support for pause menu w/rematch,exit

* Serialization & Rollback Redux
** Fix the memory management story
** Come up with a real serialization solution
** Handles rather than pointers where appropriate
** Serializable pointers where appropriate (prototype in s_ptr)
** Synctest support to validate, sanity check
** Debug support for loading, saving state

* Start on netplay support after maybe a *little* cleanup

ENGINE AFTER GAMEPLAY SLICE:
* Messaging/Event system so callbacks from components can happen without introducing gross dependencies everywhere? 
* Some basic ECS cleanup
** UUIDs, not enums?
** Get rid of Create/ReleaseComponent() calls?
** Allow for more than one component per object for a given component type.
* Debug drawing
* Hot-reloading for C++ changes
* Hot-reloading for assets

--------------------------------------------------------------------------------
DONE:
* Cleaner ECS setup - use Object class + subsystem, asset providers [X]
* Characters - procedural cubes
** Procedural meshes + rendering
* A little more math - 3D rotations
* 3D camera
* Input subsystem/component and game controls
** Reasonable association between devices and players. 
*** Multiple control contexts. Navigating menu vs. in-game?
**** Must assign controllers to instantiate sensible local game control context.
**** Network control device for online session.
*** Keyboard always p1 for now.
** Raw state (this frame, previous frame) - bit fields
*** Device-to-bit-index mappings for raw state. Bit indices defined per-game.
*** i.e. GLFW_GAMEPAD_BUTTON_Y -> SANDBOX_INPUT_JUMP
** Held, released states (input index corresponds to bitfield index)
* SandboxGame -> PaddleArena
* Stage/Arena
* Actual paddles and paddle proportions
* Collision
** Collision geometry in object-local space. Requires some more math.
* Collision handling, overlap resolution
** Check out: https://blog.hamaluik.ca/posts/simple-aabb-collision-using-minkowski-difference/
* "Ball" - procedural cube, 3d rigidbody (!)
* Debug + Fix collision flags not working as intended
* Volumetric fonts 

* Scoring & display
** Need to revisit a few fundamental questions: what is the "resolution" 
   for this game? Need this for proper font rendering, and to properly
   capture the general illusion of OLD GAEM.
** Worry about this after the font rasterizer works :P

* Full game loop iteration (losing + winning)
* Timer system
* Maintain aspect ratio !
